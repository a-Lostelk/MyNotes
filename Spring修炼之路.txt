 						Spring框架学习
Spring简介
	是软件行业的春天，整合目前的存在的大量Java框架,并不去创建新的框架,而是利用现有的轮子让项目走的更顺畅
	一切的资源都是来自于javabean,IOC容器的作用就是管理这些bean和之间的关系
	可以和其他框架整合,Mybait,SpringMVC

优点
	轻量级框架
	ioc容器		控制反转
	Aop面向切面编程
	对事务的支持
	对框架的支持
支持test测试
	junit单元测试,不用启动服务器
	beans	创建对象的,类似于一个工厂
	core	核心一切的基础
	context
	SpEL	Spring的表达式语言
Spring相关技术
	JMS:邮件服务
	WeboScket
	AOP切面
	Asoects
IOC---inversion ofcontrol	控制反转
	对象由原来的程序本身主动创建,变成了程序接受对象
	程序员主要精力主要集中于业务的实现,实现了service和dao层的分离
	没有直接依赖关系
	Spring的核心功能就是IOC功能
	
ApplicationContext上下文环境
	Spring有两个核心接口:BeanFactory和ApplicationContext,ApplicationContext是BeanFactory的
	子接口,Spring是生成Bean实例的工厂,IOC容器管理Spring中的bean
	Spring的配置文件通常是通过@Resource对象传入,@Resource是资源访问接口
	在Spring中所有的组件都是看做是bean处理,Spring容器的作用就是管理bean与bean之间的依赖关系
	bean需要接受实例的时候无需访问实例,只需要接受容器将被依赖的bean注入到依赖的bean中

涉及到的模式
1.简单工厂
	又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。
	实际上就是一个工厂类根据传入的参数,动态的决定应该创建哪一个类
	Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean
	对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定
2. 工厂方法（Factory Method）
	定义一个创建对象的接口,让子类去决定改实现哪一个类
3. 单例
	保证一个类仅有一个实例，并提供一个访问它的全局访问点
	Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。
	但没有从构造器级别去控制单例，这是因为Spring管理的是是任意的Java对象
4. 适配器（Adapter）
	将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作

IOC其实是一种编程思想
	由主动编程编程为被动接收,
	IOC容器实际上是Bean工厂---BeanFactory
	工厂模式
	代理模式:静态代理
		代理对象和目标都要实现共同的接口
		代理对象持有目标对象引用,重写构造方法
		实现共同的行为,代理对象的增强行为

关系
	如果dao的实现发生改变,应用程序本身会发生改变
	对象是由Spring容器创建的,容器里面有一个Bean工厂,负责生产对象
	对象的属性也是有容器设定的
	这个过程就是控制反转,客户端控制Spring容器创建和设置对象和属性

	控制的内容:是指谁来控制对象的创建,传统的应用程序对象的创建是由程序本身控制,
	Spring容器来创建对象,不用开发者自己创建而是容器来创建,开发者自身专注于业务的开发
	
	反转:创建对象的权限的反转,正转是指程序来创建对象,反转指程序本省不去创建对象,而是被动的接收由容器创建好给程序的对象
	
	总结:以前对象是由程序本身来创建,Spring将创建好的对象传递给程序

IOC(Inversion of Control)
	是指容器控制对象之间的关系,控制权由应用代码转到了外部容器,对象之间相互依赖耦合度非常紧密
	依赖注入:组件之间的关系由容器在运行的时候决定

控制反转
	所有的类都会在spring容器中登记，告诉spring这是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，
	把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象
	生存周期的不再是引用它的对象，而是spring

使用IOC创建的三种方式
	通过无参的构造方法
	通过有参的构造方法来创建
Bean.xml 的配置
	根据参数的下标
	根据参数的参数名
	根据参数的类型

控制反转---依赖注入
   dependency injection
   依赖:指对象创建依赖于容器,bean对象的依赖资源
   注入:指bean对象依赖的资源由容器来设置和装配
	Spring注入---setter方法
		要求被注入的属性必须有set方法,set方法的有set属性,如果属性是boolean类型

AOP(Aspect Oriented Programming)
	 面向切面编程,通过预编译和运行动态代理实现程序功能的统一维护的一种技术
	 AOP利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，
	 并将其名为“Aspect”
	 简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来

DI(依赖注入)
	一个类可能会持有另一个类的对象,降低对象之间的耦合度(类与类,对象与对象之间的联系)

面向对象编程(OOP)
	引入封装,继承,多态等概念建立一种对象层次结构,用于模拟公共行为的一个集合,

对AOP的支持
	由IOC容器负责生成,管理,依赖关系也是IOC容器负责管理
	默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了
	当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB

概念
	面向切面编程，指扩展功能不修改源代码，将功能代码从业务逻辑代码中分离出来
	主要功能：日志记录，性能统计，安全控制，事务处理，异常处理等等
AOP底层实现
	(1)使用JDK动态代理实现。
	(2)使用cglib来实现
静态代理
	使业务代码和日志代码完全分离
	代理对象和被代理对象必须实现同一个接口,被代理对象只保持相关业务代码,代理对象实现与日志相关的服务,在需要
	实现被代理对象的功能的时候调用真实对象


Bean的作用域
scope就是作用域
	单例singleton,有一个计数器记录,整个容器中只有一个对象,重复调用的也是这个对象
		在默认情况下,在启动容器的时候(即初始化容器的时候)初始化,
		lazy-init:延迟初始化bean
	propert:原型,每次获取Bean的时候都会创建一个对象
		容器会延迟初始化,Spring在读取XML文件的时候并不会立即创建对象,而是第一次请求该bean时才初始化	
		访问prototype的bean时，Spring容器都会调用其构造器创建这个对象
			request:每次HTTP请求的时候创建一个对象
			session:在会话的范围内是一个对象
			global session只在protlet下有用,表示的是application
Bean的自动装配
	autowire自动装配,简化Spring配置
	byName 根据名称查找响应的Bean对象,如果有就自动配置
		根据setter方法名
	byType:根据类型自动装配,类型不能重复只能有一个
	no:就是不适用自动装配
	constructor	通过构造器实例化bean,使用byTepe的方法配置构造方法
	
AOP详解
	面向对象编程,是OOP的补充和完善
	OOP:引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合
	AOP:它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行
		为封装到一个可重用模块，并将其命名为"Aspect"，即切面
	简单来说,就是讲那些和业务无关为业务所共同调用的逻辑或责任封装起来,减少系统的重复代码
	提供声明式服务(声明式服务)
	允许用户实现自定义切面             

SpringAOP的核心概念
	1、横切关注点
	对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点
	2、切面（aspect）
	类是对物体特征的抽象，切面就是对横切关注点的抽象
	3、连接点（joinpoint）
	被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的
	方法，实际上连接点还可以是字段或者构造器
	4、切入点（pointcut）
	对连接点进行拦截的定义
	5、通知（advice）
	所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类
	6、目标对象
	代理的目标对象
	7、织入（weave）
	将切面应用到目标对象并导致代理对象创建的过程,并创建一个被通知对象
	8、引入（introduction）
	在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段

Spring aop的重要性
	将公开的事务(如日志,安全)和领域业务整合在一起,当执行领域业务的时候讲公开业务加进来,实现公开业务的重复利用,
	开发者专注于领域业务,本质还是动态代理
通过注解实现aop
	@aspect,表示该类是一个程序的切面
	在ApplicationContext.xml文件下配置
	<aop:config proxy-target

切面
	就是在一个怎么样的环境下工作

通知
前置通知
	在目标方法开始之前执行的通知,但这个通知不能阻止连接点之间的执行流程
	前置通知使用 @Before 注解,并将切入点表达式的值作为注解值
	例如excution(*cn.sxt.service.impl.*.*(..))
后置通知
	在某个连接点正确,在目标方法执行之后，无论是否发生异常，都进行执行的通知
	@After
返回通知
	在目标方法正常结束时，才执行的通知
	@AfterReturning
异常通知
	在目标方法出现异常时才会进行执行的代码
	@AfterThrowing
	throwing属性：访问连接点抛出的异常
环绕通知
	是所有的通知中最为强大的,能够全面的控制连接点
	@Around
	getSignature获取签名,就是执行方法的类名方法名
	proceed()方法执行方法

@Aspect的指示器
	execution() 依据返回类型,全类名,方法列表,来匹配切点,可使用通配符
	this()	标注匹配类型的所有方法,必须全类名
	args() 标注匹配的参数列表
	target() 标注匹配类的所有方法,必须全类名
	@annotation() 标准匹配注解的方法必须全类名
	@within() 标注使用指定注解类的所有方法,及其子类必须全类名
	@args() 标注参数注解,此参数类型使用指定注解时必须全类名
	@target() 标注匹配注解类的所有方法

环绕通知
	是AOP中最强大的通知,可以同时实现前置和后置通知


领域业务(模型),某一个领域的业务,例如支付业务中有支付宝和微信支付,将领域业务和公共业务的分离

引入(Introduction)
	允许我们在现有的类中添加自定义的方法和类
切点
	告诉Spring在什么时候启动拦截并织入对应的流程中,往往是正则表达式来限定
连接点
	需要拦截的东西
织入
	生成一个代理对象并将切面内容放入到对应的的流程中,静态代理或是动态代理
引入
	可以加入新的方法和类




实现AOP的方式


观察对象的状态发生改变的时候,
	所有的观察者对象都会发生改变
建造者(Builder)模式
	属于对象的创建模式,将一个产品的内部属性和产品的生成过程分割,从而可以使得在建造
Spring对AOP的支持
	pring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理
	默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了
	当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理
代理
	静态代理
	抽象角色---一般使用接口或者抽象类来实现
	真实角色---被代理的角色
	代理角色---代理真实角色:一般会执行一些附属的角色,行为的属性和真实对象类似,一般来说,客户端会使用一些代理角色来进行操作
		代理对象和真实对象由依赖性

Spring的三种代理模式
	代理(proxy)是一种设计模式,提供了对目标对象另外的访问方式,可通过代理对象去访问目标对象,可以在实现目标的同时,增加额外
	的功能操作,拓展目标对象的功能

静态代理的优点
	真实对象专注于业务逻辑,使真实对象变得更加纯粹,并不会参与到其他事务
	公共业务发生改变或者拓展时,变得更加集中和方便
缺点
	增加一些代理类,工作量变大了,开发效率降低了

动态代理
	和静态代理的对象大致相同
	动态代理的代理类是动态生成的
	只需要一个代理类就可以实现所有的接口
	动态代理可以提供对另一个对象的访问，同时隐藏实际对象的具体事实
基于接口的动态代理
	JDK动态代理
	java开发包包含了对动态代理的支持,其实只是对接口的实现,proxy是获取动态代理对象,InvocationHandler接口是约束调用者实现
	Spring的AOP就是基于动态代理的实现
基于类的动态代理
	现在基本上是使用cglib来生成动态代理
类proxy
	提供创建动态代理的静态方法,他还是由这些创建的所有的动态代理的超类,创建某接口的代理
	newProxyInstance
		会有一个类加载器ClassLoader Loader,将指定的.class字节码文件加载到java虚拟机中
InvocationHandler接口
	通过反射机制实现,方法名调用方法
	Object invoke(Object proxy, Method method, Object[] args)
	第一个是代理实例,被拦截的方法,该方法的参数列表
	proxy被代理的对象	method要调用的方法	Object[] args所需要的参数

public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)
			throws IllegalArgumentException
	ClassLoader  loader：类加载器
	Class<?>[]  interfaces：得到全部的接口
动态代理
	jdk自带的动态代理机制,继承JDK里面的InvocationHandler接口动态的创建接口类,使用动态代理需要四个角色:
	被代理的类,被代理类的接口,织入器和InvocationHandler

动态代理的一般步骤：
	1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);
	2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类
		Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});
	3、通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型
		Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});
	4、通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入
		Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));
		为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。
		生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，
		而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）	

总结:Spring的AOP可以被看做是一个动态代理的框架


CGLIB代理
	CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop）中，用以提供方法拦截操作
	CGLIB代理主要是通过对字节码的操作,为对象引入简洁级别,以控制对象的访问,JDK动态代理只能对接口进行代理,CGLIB代理
	可以代理一个普通的java类
	子类继承代理类实现,也就是说,代理类是委托类的子类
	
ASM
	java字节码操控框架,能够用来动态生成类或者增强类的既有功能,可以直接产生二进制的class文件,也可以在类被
	加载入 Java 虚拟机之前动态改变类行为

Enhancer
	代理类,不仅可以代理普通的class类,也能代理接口,创建一个被代理的对象的子类,并且拦截所有的方法调用

JDK的动态代理和CGLIB代理
	JDK的动态代理有一个限制,必须要实现一个或多个接口,cglib不需要实现接口就可以
	CGLIB有一个强大的代码生成包,可以在运行期间拓展java类和实现java接口



常见的java模式
观察者模式
	是对象的行为模式,定义了一种一对多的依赖管理,让多个观察者对象监视被观察对象的状态,当被过程中具有不同的产品对象

Spring和数据库编程
配置数据库资源的三种方式
	1):使用Spring内部的类,简单的数据连接,一般用于测试
	2):使用第三方数据库连接池,如DBCP连接池
	3):JNDI获取数据源,从服务器上配置数据源,Tomcat等javaEE服务器
Spring的一个主导思想就是,给予常用技术以模块化的编程减少开发者的工作量

JDBC代码失控后的解决方案:JdbcTemplate
	在执行多条SQL语句的时候,会使用excute方法,excute方法中含有ConnectionCallback和StatementCallback等接口进行回调,
	从而完成相应的功能

数据库连接池的基本思想
	为数据库连接建立一个缓冲池,放入一定量的数据库连接,需要使用时就在资源池中取出一个使用完毕后就放回
	一般的jdbc连接在每次数据库操作的时候就会建立一个数据库连接,jdbc没有保持持续连接的能力,在超过一段时间(几百毫秒之后)
	就会自动关闭连接,连接池会根据你的配置初始化多少数据库连接给你使用既不会造成资源的浪费也不会造成连接的阻塞


连接池需要注意的问题
	并发问题:必须考虑到多线程环境,要为每一次数据库连接上线程锁,放置资源相互占用和冗余
	多数据库和多用户:设计一个符合单例模式的连接池管理类,在连接池被创建的时候读取一个资源文件,资源文件中是多个数据库的
			配置信息,为每一个数据库设定一个唯一的名字,
	事务的处理:根据事务处理的原子性,如果事务在连接的时候出现错误,那么之后的操作都不会继续执行
	连接池的分配和释放:将尚未被使用的数据库连接放入到空闲池中,当需要连接的时候,就把建立时间长的连接分配给请求的资源,如果
			该连接不可用,就会从空闲池中移除
	连接池的维护和配置:设置最大和最小连接数量,既不会造成资源的浪费也不会造成资源阻塞

Spring-mybatis整合
	大部分的互联网项目都是用SSM搭建平台的,Spring的IOC可以有效管理各类java资源,AOP可以使得数据库的事务交于Spring处理,然后配合
	mybatis对数据库持久化层的灵活运用,可以构建高性能的大型网站
整合的步骤
	1)配置数据源,一般是使用第三方的数据库连接池
	2)配置SqlSessionFactory(SqlSessionFactory是生成SQL会话的基础)
	3)选择配置SqlSessionTemplate
	4)配置Mapper
	5)事务的管理
配置SqlSessionFactoryBean
	 该类中包含几乎所有mybatis的组件,可以在Spring的XML文件中配置它可以通过IOC容器的注入来读取一个配置文件,使得
	 SqlSessionFactoryBean的配置都可以在Spring的规则下执行
配置SqlSessionTemplate
	是线程安全的类,保证每个线程的SQLSession是唯一的不会冲突,并且提供了一些功能
配置MapperFactoryBean
	通过实现一个接口,而并不需要提供一个实现类,适合于只有接口的场景
	MapperScannerConfigurer:通过扫描的形式进行配置Mapper的类,可以通过一些简单的配置然后生成大量的Mapper
		basePackage:指定Spring扫描扫描包,它会逐层深度的扫描
		annotaionClass:表示这个类在被注解标识的时候才进行扫描

Spring数据库事务管理
	在互联网系统中,面对这高并发有着成千上万的线程在并发运行,也就会涉及到很多的数据库事务
	数据库事务要么成功要么失败,一个事务的运行不会影响另一个事务的操作
	Spring的传播行为为我们带来了比较方便的解救方案
Spring数据库事务管理器
	数据库事务管理是通过一个接口来实现的
	1)事务的创建,提交和回滚都是通过内部的接口来实现的
	2)只要有任何异常错误,数据库事务都会回滚,也就是回归到最初执行状态
	3)当无异常发生的时候.数据库事务才会最终提交
配置数据库事务管理器
	定义了数据库管理事务,告诉了Spring数据库事务已经交由管理器DataSourceTransactionManager来执行
声明式事务
	是一种约定性的事务,当数据库事务发生异常的时候就会回滚事务,而不发生异常则提交事务,Spring会让事务管理器
	完成回滚或者提交的事务
	声明事务允许实现自定义接口,XML或者注解Transactional进行配置

Transactional配置的内容
	1)value:定义事务管理器,是SpringIOC容器中的一个Bean id
	2)transactionManager:同上
	3)isolation:隔离级别,这是一个数据库在多个数据库事务同时存在时的概念,默认值取数据库默认隔离级别
	4)propagation:传播行为,是方法之间调用的问题
	5)readOnly:是否开启只读事务,默认是false
	6)timeout:超时时间,在超过一定的时间之后会引发异常,默认会导致事务回滚
	7)rollbackFor:回滚异常类定义,产生了所定义的异常后就回回滚事务,否则就提交事务
	7)rollbackForClassName:回滚异常类事务类名定义,
	8)noRollbackFor:在发生某些异常后不回滚事务,当定义的异常情况发生了,继续提交事务

	Transactional的底层是Spring AOP动态代理技术,静态和非public方法注解是失效的,自调用的过程中也会发生失效问题
	自调用:就是一个类的方法去调用这个类中另外一个方法的过程


SSM+Redis框架示意图
	Spring+SpringMVC+MyBatis+Redis
	1)SpringIOC充当的是资源整合管理的功能
	2)SpringAOP提供的面向切面管理,特别数据库管理的功能
	3)SpringMVC主要管理的是控制器的功能,
	4)Mybatis提供的数据库持久层,负责数据的存储和取出
	5)Redis是一个缓存工具,提供了高速处理数据和缓存数据的功能,系统大多数情况下只需要访问缓存无需直接从数据库磁盘中读写操作
	要知道从内存缓存里面读取数据的速度是从磁盘中读取速度快很多

数据库事务的ACID特性
	原子性(Atomaictity):整个事务的所有操作要么全部完成,要么全部不完成,并不会在其中某一个环节中滞留,事务在执行过程中发生错误
				会回滚到事务开始的状态
	一致性(Consistency):事务可以改变封装状态,但始终与系统保持一致的状态,系统滞挺事物的操作也不会进行
	隔离性(Isolation):两个事务之间的隔离性,互不干涉,互不影响
	持久性(Durability)在事务执行完后,该事务对数据库所做的更改持久保存在数据库之中,并不会被回滚

隔离级别
	脏读(dirty read):允许一个事务去读取另一个事务为提交的数据
	读/写提交(read commit):一个事务只能读取另一个事务已经提交的数据(存在一个问题就是不可重复读,一个事务无法知道另一个事务
				在提交之前的行为)
	可重复读(repeatable read):使得同一条数据库记录的读/写按照一个序列化进行操作,不会产生交叉情况,保证了一条数据的一致性
	序列化(Serializable):是一种让SQL按照顺序读写的方式,消除了数据库事务之间并发会产生数据不一致的情况
	自下而上,脏读到序列化的性能直线下降.会导致大量的线程挂起并且处于等待的状况,在大部分场景下,读/些提交的方式设置事物的方式
	更适宜

传播行为
	是指方法之间调用事务策略的问题.方法调用时存在的7钟传播行为
	PROPAGATION_REQUIRED:如果不存在当前事务就创建,之前的方法存在事务就继续使用之前的事务
	PROPAGATION_SUPPORTS:不存在当前事务就不启用,存在当前事务,就继续使用当前事务
	PROPAGATION_MANDATORY:方法必须在事务内运行,没有活动的事务就会抛出异常
	PROPAGATION_REQUIRES_NEW:无论是否存在当前事务,方法都会在新的事务中运行

XML
	ref对象引用类型,value是字符创引用类型
	ref表示的是对象的引用.value是引入这个对象的名字的字符串
jackson
	基于java的应用库或框架,可以将java对象转换成json对象和xml文档,也可以将xml,json对象转换成java对象
json实例
	@SuppressWarnings该批注的作用是给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默,允许选择性的取消
	特点代码块中的警告,当出现某种警告的时候,确定它并不是错误,
		   deprecation   使用了不赞成使用的类或方法时的警告 
		   unchecked     执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。 
		   fallthrough   当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。 
		   path          在类路径、源文件路径等中有不存在的路径时的警告。  
		   serial        当在可序列化的类上缺少 serialVersionUID 定义时的警告。  
		   finally       任何 finally 子句不能正常完成时的警告。 
		   all           关于以上所有情况的警告。 

声明式事务和编程式事务
	Spring支持声明式事务和编程式事务两种事务的管理方式
声明式事务的两种使用方式
	ProxyFactoryBean + xml		上古时期
	tx:advice+aop命名空间		一次配置永久生效
	注解	@Translational		注解控制(推荐)
声明式事务独有的概念
	声明式事务使业务代码不收影响,普通的POJO对象也可以接受事务的管理,声明式事务不足之处就是最细方法粒度都是建立在方法级别上
	当抛出运行期异常(RunTimeExpection)Spring会执行回滚操作,并不会对编译器异常进行回滚操作,可能存在某些操作成功某些操作失败的情况
	
@Repository
	标注这是一个数据库接口层.@AuthWrized不会提示错误
	
	
单例模式
	是单例对象的类只允许一个类存在,并自行实例化并将这个实例提供给整个系统使用,比如读取配置文件的单例对象统一读取,其他所有的需要
	读取配置文件的对象提供这个实例读取配置文件

Spring中bean的作用域与生命周期
	Spring的Bean默认都是单例的
	组成应用程序主体和由Spring IOC管理的对象都为bean
	定义了五种作用域
		singleton（单例）、prototype（原型）、request、session和global session
		singleton:单例模式,在 IOC容器中只会存在一个bean的实例,无论被多少次引用,最终指向的是同一个对象
		prototype:原型模式,
		request:每一次HTTP请求容器都会返回一个该bean的实例,在HTTP请求结束的时候回销毁该实例,
		session:在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效
				session请求结束后该实例被销毁
		global Session:在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。	
		
	生命周期:
		容器管理Sinleton作用域下的bean生命周期,何时被创建和销毁,prototype作用域的bean只负责创建不负责销毁,创建了实例交由客户端处理bean
		的生命周期
		







