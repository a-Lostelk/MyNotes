---
typora-root-url: images
---

### 配置Spring工程日志文件

![](/QQ截图20191205155859.png)

- 问题描述：启动项目的时候提示无法找到日志配置文件的错误

  解决：排除Springboot中的默认日志配置，在Spring的高版本中需要在资源文件夹中出啊创建log4j.properties文件

```xml
<exclusions>
    <!-- 排除默认日志配置 -->
    <exclusion>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-logging</artifactId>
    </exclusion>
</exclusions>
```



### list集合判空

- 在java中这是一种常见的错误写法，list是一个集合尽量使用`isEmpty()`方法来判断list集合是否为null


```java 
if (list != null && list.size() != 0)
{
   map.put("message", "success");
   map.put("status", 4);
   map.put("data", list.get(0));
}


if (!list.isEmpty() )
{
    map.put("message", "success");
    map.put("status", 4);
    map.put("data", detail);
}else
```



### SpringBoot项目添加热部署插件

- Springboot无法像SSM项目中可以选择更新资源文件，添加自动热部署插件，可以在修改Java代码后不用重新启动


```xml
<!--Spring boot 热部署插件-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>
```



- idea在启动项目的时候显示为结束的语法错误，需要将idea的项目编码设置为UTF-8格式


### mybatis的二级缓存

```xml
<settings> 
        <setting name="cacheEnabled" value="true" /><!-- 全局映射器启用缓存 -->   
        <setting name="useGeneratedKeys" value="true" /> 
        <setting name="defaultExecutorType" value="REUSE" /> 
</settings>
```

在Mybatis的全局配置文件中



### `@SuppressWarnings`的作用

该批注的作用是给编译器一条指令，告诉它对被批注的代码元素内部的某些警告保持静默，允许您选择性地取消特定代码段（即，类或方法）中的警告，将存在的编辑器认为是错误的非错误内容屏蔽

### Sql优化

- 在SQL优化中，子查询的效率是比连接查询效率低很多，子查询在查询的时候某个字段是来自于另外一张表，会创建一个临时表，在查询结束后再删除这些临时表，连接查询是将查询的各个表中通过某些字段通过于当前表的字段匹配成功后关联到当前表中，由此看出，子查询多了创建表和销毁表的过程，对性能有一定的影响



- 一个简单的Oracle的存储过程函数

```PLSQL
CREATE OR REPLACE procedure UPDATE_AGE
(uname in varchar, uage in int)
as
begin
  UPDATE students SET USERAGE = USERAGE + uage WHERE USERNAME = uname;
  COMMIT;
END UPDATE_AGE;


-----------------------------------
exec SP_UPDATE_AGE	--调用执行存储过程函数

```

### loop游标循环

```PLSQL
DECLARE
  x NUMBER := 100;
BEGIN
  FOR i IN 1 .. 10 LOOP
    IF MOD(i, 2) = 0 THEN
      dbms_output.put_line('i:' || i || 'is even');
    ELSE
      dbms_output.put_line('i:' || i || 'is odd');
    END IF;
    x := x + 100;
    dbms_output.put_line('x的值是' || x);
  END LOOP;
  COMMIT;
END;  
```

while循环



- `<c:choose>`

  `<c:choose>` 和 `<c:when> 、 <c:otherwise> `一起实现互斥条件执行，类似于 java 中的 if else.

  `<c:choose>` 一般作为` <c:when> 、 <c:otherwise> `的父标签。

  


### @Resource和@Autowired

都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入

`@Autowried`是按照bean的类型来装配依赖对象，默认依赖对象必须存在，可以和`@Qualifier`根据名字搭配一起使用

`@Resource`默认按照ByName自动注入，有两个重要的属性：name和type

### **Class.getResource**和**ClassLoader.getResource**

**根据**

`byte[] buffer = new byte[fis.available()];`中的available()确定输出流中的数据的大小


- **Cipher**类介绍

  **该类是JCE框架的核心**，ENCRYPT_MODE,加密数据 ，DECRYPT_MODE,解密数据 



- Map.keySet()返回key的集合，Map中键是唯一不可重复的，因此是用无序不可重复的set集合来保存



- cookie的一些操作

  ```java
  //依次取得cookie中的名称、值、最大生存时间、路径、域和是否为安全协议信息
  String cookieName = cookie.getName();
  String cookieValue = cookie.getValue();
  int maxAge = cookie.getMaxAge();
  String path = cookie.getPath();
  String domain = cookie.getDomain();
  boolean isSecure = cookie.getSecure();
  ```


### 问题描述

在SVN拉取的Springboot项目在本地部署始终无法运行，启动始终停在初始化SpringMVC的dispatchServlet无法继续

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
    <version>2.0.4.RELEASE</version>
</dependency>
```

Spring Boot的核心思想"**习惯优于配置**"的理念，自动化实现Springboot容器中的各个组件的配置，`Actuator` 是 Spring Boot 提供的对应用系统的自省和监控的集成功能，可以查看应用配置的详细信息，例如自动化配置信息、创建的 Spring beans 以及一些环境属性等


- 实体类中的JackSon的一些注解

  `@JsonIgnore`此注解用于属性或者方法上（最好是属性上），用来完全忽略被注解的字段和方法对应的属性，即便这个字段或方法可以被自动检测到或者还有其他的注解，一般标记在属性或者方法上，返回的json数据即不包含该属性

  `@JsonProperty` :此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty("name")。 对属性名称重命名，比如在很多场景下Java对象的属性是按照规范的驼峰书写

  `@JsonFormat`此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式，`@JsonFormat(pattern="yyyy-MM-dd hh:mm:ss")`

  `@JsonInclude `属性值为null的不参与序列化。例子：@JsonInclude(Include.NON_NULL)



- Mybatis中的`concat`函数

  ```xml
  and a.TITLE like concat('%',concat(#{article.title},'%'))			
  ```

  可以拼接2个字符串，如果是需要嵌套多个字符串，可以在`concat`函数中嵌套`concat`函数

  

- JavaScript中的`this`函数的详解

  JS的函数的最终定义是函数执行的时候，该函数被哪个对象调用了，这个this就指向谁，谁调用他，this指向谁

  JS中一个函数中包含很多个对象，this关键字所在的对象呗最外层对象所调用，this仍然是指向的是上一级对象

  ```javascript
  var o = {
      a:10,
      b:{
          // a:12,
          fn:function(){
              console.log(this.a); //undefined
          }
      }
  }
  o.b.fn();
  ```


  特殊实例：

  ```javascript
  var o = {
      a:10,
      b:{
          a:12,
          fn:function(){
              console.log(this.a); //undefined
              console.log(this); //window
          }
      }
  }
  var j = o.b.fn;
  j();
  ```

  

### 使用echarts生成动态数据地图

1. 查询地理坐标等相关信息

   ```sql
   ## MAPX ，MAPY是地理坐标
   select T.ENTNAME,T.pripid ,MAPX,MAPY from (
   select entname, pripid from ((select entname,pripid from ZR_YD_SCALETAXES)
   union all  (select entname,pripid from ZR_YD_ECONOMIC)
   union all  (select entname,pripid from ZR_YD_ELECTRICITY)
   union all  (select entname,pripid from ZR_YD_FOREIGNTRADE))
    group by entname, pripid ) T,e_baseinfo
    where T.pripid=e_baseinfo.pripid
   ```

2. 返回list集合并使用Gson转换为JSON对象串

   ```java
   @ResponseBody
   @RequestMapping(value = "/queryTest",produces = "text/html;charset=UTF-8")
   public String queryTest() throws Exception {
       PageData pd = this.getPageData();
       int isok=0;
       int isno=0;
       List<PageData> list = null;
       List<PageData> reallist= new ArrayList<>();
       try {
           list = activityService.queryTest(pd);
           for(PageData pageData:list){
               // （百度多边形区域经纬度集合）
               String partitionLocation = "25.962105_115.133713,25.196774_115.345521,26.85198_116.34625";
               reallist.add(pageData);
               isok++;
           }
           System.out.println("isOk:"+isok+"----"+"isno"+isno);
       } catch (Exception e) {
           e.printStackTrace();
       }
       return new Gson().toJson(reallist);
   }

   ```

  3. 引入相关JavaScript文件，`src="http://api.map.baidu.com/api?v=2.0&ak=您的密钥"`

     ```JavaScript
     <script type="text/javascript" src="http://api.map.baidu.com/getscript?v=2.0&ak=3ChLlvZBHDPtbomjUQNV8TCV9fBq8o9k"></script>
     ```


  4. 存放地图的html容器

     ```html
     <div class="map">
         <div class="map_echart" id="cancelmap_echart"></div>
     </div>
     ```


  5. JavaScript的的数据渲染和样式设置

     ```JavaScript
     <script type="text/javascript">	//文档加载完立即执行该方法
         $(function () {
             queryMapDatas('', '1');
         });

      function queryMapDatas(datadate,type){
          // 百度地图API功能、创建Map实例，并装载到html容器中
          map = new BMap.Map("cancelmap_echart");// 
          // 初始化地图,设置中心点坐标和地图级别
          map.centerAndZoom(new BMap.Point(115.421712, 25.958804), 14);
          map.disableAutoResize();
          // 设置地图显示的城市 此项是必须设置的
          map.setCurrentCity("赣州市于都县");
          // 开启鼠标滚轮缩放
          map.enableScrollWheelZoom(true);
          //设置地图的相关样式
          map.setMapStyle({
              styleJson:[ {
                         'featureType': 'land',     //调整土地颜色
                         'elementType': 'geometry',
                         'stylers': {
                             'color': '#27417B'
                         }
                     },{
                         'featureType': 'building',   //调整建筑物颜色
                         'elementType': 'geometry',
                         'stylers': {
                             'color': '#04406F'
                         }
                     },
                         //......
     	 var num = 0;
             $.ajax({
                 url: contextPath + "/activityController/queryTest",	//请求后台的JSON数据
                 type: "POST",
                 dataType: "json",
                 data:{
                     DATADATE : datadate,	//传入的的数据：可选
                     TYPE : type				//传入的的数据类型：可选
                 },
                 success: function (text) {
                     layer.closeAll();
                     var bdary = new BMap.Boundary();
                     bdary.get("赣州市于都县", function (reslult) {// 获取行政区域
                         map.clearOverlays();               // 清除地图覆盖物
                         var count = reslult.boundaries.length;  // 行政区域的点有多少个
                         if (count === 0) {
                             alert('未能获取当前输入行政区域');
                             return;
                         }
                         var pointArray = [];
                         // 建立多边形覆盖物
                         for (var i = 0; i < count; i++) {
                             var ply = new BMap.Polygon(rs.boundaries[i], {
                                 strokeWeight: 2,
                                 strokeColor: "#ff0000",
                                 fillOpacity: "0.1"
                             });
                             map.addOverlay(ply);  // 添加覆盖物
                             pointArray = pointArray.concat(ply.getPath());
                         }
                         map.setViewport(pointArray);//调整视野
                         var markers = [];
                         // 遍历坐标数组
                    		// 最终将JSON数据渲染为图表地图中的点    
                         for (var x=0 ; x < text.length;x++){
                             num++;
                            // 横纵坐标定点 ENTNAME，循环根据数据中的坐标将数据定位到相应位置
                             var point = new BMap.Point(text[x].MAPX, text[x].MAPY);
                             var marker = new BMap.Marker(point);
                             // 获取数据
                             var param = text[x].ENTNAME;
                             // 添加点击事件
                             addClickHandler(param, marker);
                             markers.push(marker);
                         }
                         // 添加点聚合效果
                         var markerClusterer = new BMapLib.MarkerClusterer(map, {markers: markers});
                     });
                 }
             });                    
      }
     </script>
     ```

     

  6. 添加点击事件

     ```JavaScript
     function addClickHandler(param,marker) {
         marker.addEventListener("click", function (e) {
             open1(param);
         }
                                );
     }

     function open1(a){
         window.open(<%= qicha %>+a);
     }
     ```






### WebMvcConfigurer配置类详解

`WebMvcConfigurer`是对传统XML项目配置的一种简化操作，使用注解活Java代码的方式拓展注册SpringMVC相关的组件，可以自定义一些`Handler（映射器），Interceptor（拦截器），ViewResolver（视图解析器），MessageConverter（消息转化器）`。

在Springboot1.5之前，是重写**`WebMvcConfigurerAdapter`**实现MVC容器的拓展

常用的方法

```java
 /* 拦截器配置 */
void addInterceptors(InterceptorRegistry var1);
/* 视图跳转控制器 */
void addViewControllers(ViewControllerRegistry registry);
/**
 *静态资源处理
**/
void addResourceHandlers(ResourceHandlerRegistry registry);
/* 默认静态资源处理器 */
void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer);
/**
 * 这里配置视图解析器
 **/
void configureViewResolvers(ViewResolverRegistry registry);
/* 配置内容裁决的一些选项*/
void configureContentNegotiation(ContentNegotiationConfigurer configurer);
/** 解决跨域问题 **/
public void addCorsMappings(CorsRegistry registry) ;
```

1. `addViewControllers`的使用，控制页面的跳转，在一个项目有多个入口的时候发挥重要作用，将某些请求路径跳向指定的页面

   ```java
   @Override
   public void addViewControllers(ViewControllerRegistry registry) {
       registry.addViewController("/").setViewName("/toLogin");
       registry.addViewController("/index").setViewName("/toIndex");
   ```

2. `addResourceHandlers`添加静态资源映射器，`addResourceHandler`是暴露给外部的资源，`addResourceLocations`是内部静态文件的存放位置，Springboot默认会加载此位置的文件

   ```java
   @Override
   public void addResourceHandlers(ResourceHandlerRegistry registry) {
       registry.addResourceHandler("swagger-ui.html")
           .addResourceLocations("classpath:/META-INF/resources");
   }
   ```

3. `addInterceptors`添加拦截器，最常见的业务场景就是，未登录的用户无法访问其他页面，只有在登录页面登录成功跳转到指定的页面，才能对项目的其他资源进行访问

   addPathPatterns(/**)表示拦截所有请求，excludePathPatterns对某些请求放行

   ```java
   @Override
   public void addInterceptors(InterceptorRegistry registry) {
       // 多个拦截器组成一个拦截器链 addPathPatterns 用于添加拦截规则，/**表示拦截所有请求 excludePathPatterns 用户排除拦截
       logger.info("注册拦截器");
       registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**")
           .excludePathPatterns("/","/toZSLogin","/zsApp/ZSLogin.html","/h5api/zslogin","/zsApp/js/**","/zsApp/css/**","/zsApp/img/**");
   }
   ```

- 获取地址栏的参数，一般是用在页面跳转的时候需要携带参数并且获取到相关参数

  ```JavaScript
  function getURLParamValue(pName)
  {
      let url=window.location.search;
      if(url.indexOf("?")!=-1)	//返回？出现的位置
      {
          let start=url.indexOf("?");
          let str=url.substr(start+1);	//从?号位置开始截取
          let strs = str.split("&");
          for(let i=0;i<strs.length;i++)
          {
              if([strs[i].split("=")[0]]==pName)
                  return unescape(strs[i].split("=")[1]);
          }
      }
      else
          return "";
  }
  ```






### Spring和Redis整合之` RedisTemplate `

对应的包是`org.springframework.data.redis.core`



| 接口              | 描述                             |
| --------------- | ------------------------------ |
| Key类型操作         |                                |
| ValueOperations | 操作Redis String（或者Value）类型数据    |
| ListOperations  | 操作Redis List类型数据               |
| SetOperations   | 操作Redis Set类型数据                |
| ZSetOperations  | 操作Redis ZSet（或者Sorted Set）类型数据 |
| HashOperations  | 操作Redis Hash类型数据               |

| Key绑定操作              |                              |
| -------------------- | ---------------------------- |
| BoundValueOperations | Redis字符串（或值）键绑定操作            |
| BoundListOperations  | Redis列表键绑定操作                 |
| BoundSetOperations   | Redis Set键绑定操作               |
| BoundZSetOperations  | Redis ZSet（或Sorted Set）键绑定操作 |
| BoundHashOperations  | Redis Hash键绑定操作              |
| BoundGeoOperations   | Redis Geospatial 键绑定操作       |

#### opsForXXX

操作Redis中的基本数据结构（Hash、String、Set、List、Zset）

```java
// hash 数据结构操作
org.springframework.data.redis.core.RedisTemplate#opsForHash
// list
org.springframework.data.redis.core.RedisTemplate#opsForList
// string
org.springframework.data.redis.core.RedisTemplate#opsForValue
// set
org.springframework.data.redis.core.RedisTemplate#opsForSet
// zset
org.springframework.data.redis.core.RedisTemplate#opsForZSet

```





### ROUND() 函数

ROUND 函数用于把数值字段舍入为指定的小数位数。

#### SQL ROUND() 语法

```
SELECT ROUND(column_name,decimals) FROM table_name
```

| 参数          | 描述             |
| ----------- | -------------- |
| column_name | 必需。要舍入的字段。     |
| decimals    | 必需。规定要返回的小数位数。 |



### 为什么需要LocalDate、LocalTime、LocalDateTime

`Data`打印出的日期没有格式化，SimpleDateFormat是线程不安全的，因此在多线程的开发环境下推荐使用`LocalDate`

### Validator

1. 第一个方法可以对整个bean对象做校验（常用）：.validator
2. 后面2个方法可以对单个属性进行校验（不常用）：.validateProperty，.validateValue

- @NotNull：不能为null，但可以为empty(""," "," ")

- @NotEmpty：不能为null，而且长度必须大于0 (" "," ")

- @NotBlank：只能作用在String上，不能为null，而且调用trim()后，长度必须大于0("test") 即：必须有实际字符

  

在某些Java Bean中某些字段需要进行判断校验，例如判空，数据校验等

```java
/**
 * 收货人姓名
 */
@NotNull(message = "收货人姓名不能为空")
private String receiver;
/**
 * 收货人手机号
 */
@Pattern(regexp = "^1\\d{10}$", message = "请输入正确的手机号")
@NotNull(message = "手机号不能为空")
private String mobile;
/**
 * 省
 */
@NotBlank(message = "省份不能为空")
private String province;

@NotNull(message = "省份id不能为空")
private Long provinceId;
/**
 * 市
 */
@NotBlank(message = "市不能为空")
private String city;
```

当发生`Validator`定义的`NotNull`或者`NotBlank`等情况，会中断业务的流程



### 集合List、Set与Map的使用场景

1. List和Set都是继承自Collection接口，Map则不是
2. List元素有放入顺序，元素可重复，和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。Set元素无放入顺序，元素不可重复，重复元素会覆盖掉，Set检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
3. Map是一个接口，适合储存键值对的数据

互联网开发中比如需要涉及到金额的订单交易，根据订单号判断不能重复，依次保证在JavaBean中只有一个订单不会发生重复，这时候就可以使用有序切不可重复的Set集合来存放有关订单号的Java Bean



### BeanUtils

进行属性的拷贝，推d荐使用是Spring的`BeanUtil`（Apache的BeanUtil存在性能上的差异）

Beanutils工具在使用时几乎只用到以下几个方法，其中一个方法通常情况下都是使用匿名内部类。

1. BeanUtils.setProperty(bean, name, value);其中bean是指你将要设置的对象，name指的是将要设置的属性（写成”属性名”）,value（从配置文件中读取到到的字符串值）
2. BeanUtils。copyProperties(bean, name, value)，和上面的方法是完全一样的。使用哪个都可以
3. ConvertUtils.register(Converter converter , ..)，当需要将String数据转换成引用数据类型（自定义数据类型时），需要使用此方法实现转换。
4. BeanUtils.populate(bean,Map)，其中Map中的key必须与目标对象中的属性名相同，否则不能实现拷贝。
5. BeanUtils.copyProperties(newObject,oldObject)，实现对象的拷贝



### SecurityUtils

`SecurityUtils.getSubject()`是每个请求创建一个Subject, 并保存到**ThreadContext**的`resources（ThreadLocal<Map<Object, Object>>）`变量中，也就是一个http请求一个subject,并绑定到当前线程

每次请求都会重新设置`Session`和`Principals`,看到这里大概就能猜到：如果是web工程，直接从web容器获取httpSession，然后再从httpSession获取Principals，本质就是从cookie获取用户信息，然后每次都设置Principal，这样就知道是哪个用户的请求，并只得到这个用户有没有人认证成功，**--本质：依赖于浏览器的cookie来维护session的** 



### @interface

`@interface`就是定义一个@Annotation注解，常见的JDK中的`@Override`，Lombok中的@Data注解，就是一个注解



### FileReader.readAsDataURL(file)

<https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader>

readAsDataURL方法会使用base-64进行编码，编码的资料由data字串开始

`readAsDataURL` 方法会读取指定的 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 或 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 对象。读取操作完成的时候，[`readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readyState) 会变成已完成`DONE`，并触发 `loadend` 事件，同时 [`result`](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result) 属性将包含一个`data:`URL格式的字符串（base64编码）以表示所读取文件的内容



### window.atob（）

<https://baike.baidu.com/item/base64>对Base64码的解码 详解

最常见的传输Bit字节码的编码方式，Base64码是将二进制文件转换成字符串，Base64编码需要解码才能读

对文件压缩后



### Blob对象

`Blob` 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。[`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 接口基于`Blob`，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。





### H5上传图片压缩

<https://www.cnblogs.com/ww03/p/9507039.html>