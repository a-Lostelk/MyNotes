---
typora-root-url: images
---

### JavaSE

#### == 和 equals 的区别是什么？

##### == 解读

- **基本类型**：比较的是值是否相同；
- **引用类型**：比较的是引用是否相同；

new一个对象会开辟新的内存空间，除非和对象本身的比较，==结果是false

##### equals解读

equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较

**总结** ：== 对于基本类型来说是**值比较**，对于引用类型来说是比较的是引用（**内存地址**）；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

```java
    String a = new String("ab"); // a 为一个引用
    String b = new String("ab"); // b为另一个引用,对象的内容一样
    String aa = "ab"; // 放在常量池中
    String bb = "ab"; // 从常量池中查找
    if (aa == bb) // true
        System.out.println("aa==bb");
    if (a == b) // false，非同一对象
        System.out.println("a==b");
    if (a.equals(b)) // true
        System.out.println("aEQb");
    if (42 == 42.0) { // true
        System.out.println("true");
```



#### Java中只有值传递



#### 面向对象和面向过程

- **面向过程** ：**面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**

- **面向对象** ：**面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。




#### 什么是JVM

Java的跨平台性就是体现在有一个强大的JVM虚拟机

- JVM即Java虚拟机，是一个可执行java字节码（.class）文件的虚拟机进程。
- Java源代码（.java）被编译器编译成字节码（.class）文件，然后字节码文件被Java虚拟机解释成机器码（不同平台的机器码不一样），最后利用机器码操作硬件和操作系统。
- 因为不同的平台装有不同的java虚拟机，它能够将相同的字节码文件解释成不同平台所需的机器码，正因为有了JVM的存在，所以java被称为平台无关的编程语言。



#### JDK和JRE

JDK有JRE的所有功能，包括javac编译工具 ，javadoc等，可以创建java程序，JRE是java的运行环境，java虚拟机、类库、java命令等集合，但是不能创建java程序

JRE是包含java的运行环境，包含了java程序运行所需要的软件环境，包括JVM和丰富的类库系统，但往往服务器上装载的并不是简单的JRE，从技术上来说，只是在服务器上运行java程序，JSP的本质上是Servlet，服务器应用程序会将JSP解析为Java Servlet ，等同于创建了一个java程序

JVM是Java虚拟机，它提供了java字节码文件运行所需要的环境支持。

简单来说：JDK包含JRE，JRE包含JVM



#### Java GC垃圾回收机制

- GC也就是垃圾回收机制，这是java和C++的主要区别之一
- gc的工作时间是不可预测的，程序员无法控制，调用`System.gc()`只会通知gc开始工作，但是gc真正开始的时间是不确定的
- 有特有的**垃圾回收算法**，判断对象的存活性，然后对不再使用的对象就垃圾回收，腾出空间给其他的对象使用



#### GC的回收算法

##### 标记——清除算法

算法分为两个过程：**1、标记正所有需要回收的对象 2、标记完成后清除被标记的对象**。其标记的过程就是判断对象**有效性**，执行可达性分析的过程

描述场景：图书管里有好多人在看书，图书管理员想要收集起没有被看的书的时候，他决定让所有正在看书的人站起来，然后询问每个人：那一本书是不看的。询问完所有的人之后，同学们做下继续看书。这时候，图书管理员开始寻找所有做过标记的书，把它们收集起来

缺点： 效率低下
1、每次进行垃圾回收时，会**暂停**当前用户程序的运行（类似让所有的同学站起来） 
2、垃圾回收器需要**间隔性**的检查，并且**标记**和**清除**的过程相对较慢。 
3、在标记清除之后可能会产生大量内存碎片，导致一旦需要为大对象分配空间时，由于找不到足够大的内存空间，而不得以引发另外一次GC过程。

##### 标记——复制算法

标记——复制存储算法通过采用双区域交替使用这种方式解决了标记——清除算法中效率低下的问题。

它将可用内存划分为**两个等量的区域**（`使用区`和`空闲区`），每次只使用一块。当正在使用的区域需要进行垃圾回收时，***存活的对象将被复制到另外一块区域***。原先被使用的区域被**重置**，转为空闲区。

描述场景：图书室一分为二(A区和B区)，同一时刻只有一块区域允许看书。开始时只允许在A区看书。当管理员想要回收A区不被看的书的时候，大喊一嗓子“正在看书的同学拿着你书到B区”。等所有人都到了B区后，图书管理员只要把A区的书收集起来，就完成了任务。下一次收集的时候，则是要求同学带着自己看的书从B区转移到A区。如此循环往复即可

缺点：会开辟多余的内存空间，要进行多次的复制操作

1、原有可用空间被缩小为1/2，空间利用率降低了。 
2、过程中也会**暂停**当前应用的运行。

##### 标记——整理算法

其标记的过程和“标记-清除”算法一样，而整理的过程则是让所有存活的对象都想另外一端移动，然后直接清理掉端边界以外的内存

暂停当前应用的运行，非实时性的回收。

##### 分代收集算法

将对象的生命周期分为三种：新生代、老年代和永久代，分代垃圾回收机制根据不同的生命周期选择不同的垃圾回收算法，本身没有产生关于Java垃圾回收的新算法



#### Java和C++的区别

- 都是面向对象的语言，支持**继承、封装和多态**
- C++支持多继承，Java只能单继承，但可以实现多个接口
- C++可以直接使用指针访问内存，Java不提供指针，相对内存更加的安全
- Java有特有的垃圾回收机制，不需要手动释放内存



#### 面向对象的三大特性

1. **封装**

   把一个对象的属性私有化，外界不能随便修改，但是提供了外界访问属性的方法，一个类必须和外部有所交流沟通，不然存在就失去了意义

2. **继承**

   一个基本类定义的一些属性和方法作为父类，基于此类新建立的新类，可以选择性实现父类的方法，也可以自己添加新的方法和属性，能灵活的复用之前使用过的代码

   - 子类拥有父类所有的属性和方法，但不代表可以访问修改，父类的私有属性和方法是无法访问，**只是拥有**
   - 子类可以复用父类的方法，也可以新增新的方法对父类进行拓展
   - 子类可以用自己的方式实现父类

3. **多态**

   所谓多态一个引用变量具体会指向什么实例对象，该引用变量的方法调用会调取哪个类实现的方法，必须由程序运行期间决定



#### 自动拆装箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；



#### final的作用

- final 修饰的类叫**最终类**，该类不能被继承。
- final 修饰的方法不能被重写。
- final 修饰的变量叫**常量**，常量必须**初始化**，初始化之后值就不能被修改。

作用在三个地方：变量、方法、类

如果是基本数据类型，表示其数值在确立了后就不能再次改变，如果是引用类型的变量，初始化后不能再指向另一个对象

作用于一个类，该类不能被继承，该类中的所有方法都默认是`final`方法



#### static关键字

1. **成员变量或方法**：`static`修饰的成员变量属于类，不但是属于类中的某个对象，被类中所有的对象共享，最好通过类名调用，`static`静态变量存放在Java内存区域的方法区

2. **代码块：**置于方法之外，会在所有方法运行之前执行，**无论该类创建多少个对象，静态代码块只会被执行一次**

3. **内部类**：静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：**1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。**

   单例模式的一种实现方式就是使用的静态内部类



#### this关键字

`this`代表当前对象，可以使用也可以不使用，推荐使用，易读易理解



#### super关键字

用于子类访问父类的变量和方法

this和super不能用在static方法中



#### 重写和重载的区别

- **重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　
- **重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

例子：**重载**在不同的情况中有不同的实现方法，比如在一个类中，**不同的构造方法用来实现不同的参数**

​		  **重写**实现父类的方法，具体实现可以自己进行拓展需求





#### Collections工具类

**排序**

```java
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。
```

**查找替换**j

```
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素
```

**Array的常见操作**

1. 排序 : `sort()`
2. 查找 : `binarySearch()`
3. 比较: `equals()`
4. 填充 : `fill()`
5. 转列表: `asList()`
6. 转字符串 : `toString()`
7. 复制: `copyOf()`



#### ArrayList和LinkedList的区别

ArrayList的底层是Object[]数组是线性表，支持多次查询的场景，LinkedList底层是链表结构，适用于多插入的场景



#### Map的特点

- 以键值对存储数据
- 键不可重复，值存储是无序的



#### HashMap的原理

底层是`entry[]`数组+链表结构，key vaule键值对是以entry[]数组对象存储，包含决定数据存放位置和确定取出数据准确性的Hash值，存放数据的key value（根据key存取值value），next指针指向下一个entry[]数组

HashMap的`entry[]`数组组成table表，每个`table`节点中包含一个`entry`数组，`entry`数组后的数据结构是链表，在JDK8之后，当链表的长度大于8之后会转换为二叉红黑树，有利用数据的遍历查找

`equal()`方法判断查找的数据是否和数组中指定位置的数组是否匹配相等，通过链表解决冲突问题



#### HashMap的扩容机制

当HashMap的加载因子到0.75，会扩容到原HashMap的大小2倍大小的新的table数组，并将原来数组中的内容复制到新数组



#### HashTable和HashMap的区别

- HashTable是线程安全的，HashMap是线程不安全的
- HashTable的key和value都不能为null，HashMap的key value允许为null，key是无序分布的，所以键也是无序的
- HashTable的初始大小是11，扩容为newSize = oldSize * 2 + 1,HashMap的初始大小是16，扩容：newsize = oldsize*2，size一定为2的n次幂；



#### 字符串类区别

String 声明的是不可变的对象，每次操作都会生成**新的** String 对象，然后将**指针指向**新的 String 对象

而 `StringBuffer、StringBuilder` 可以在原有对象的基础上进行操作

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的

线程安全高执行效率低，线程安全低执行效率低



#### String str="i"与 String str=new String("i")

内存分配的方式不一样，String str = "i"会将其分配到**常量池**中，String str = new String("i")开辟**新的内存空间**，放入到堆内存中



#### String类的常用方法


indexOf()：返回指定字符的索引。

charAt()：返回指定索引处的字符。

replace()：字符串替换。

trim()：去除字符串两端空白。

split()：分割字符串，返回一个分割后的字符串数组。

getBytes()：返回字符串的 byte 类型数组。

length()：返回字符串长度。

toLowerCase()：将字符串转成小写字母。

toUpperCase()：将字符串转成大写字符。

substring()：截取字符串。

equals()：字符串比较。



#### 抽象类和普通类的区别

- 普通类不能包含抽象方法，抽象类可以包含抽象方法。
- 抽象类不能直接实例化，普通类可以直接实例化。
- 抽象类不能被`Final`修饰



#### 接口类和抽象类的区别

- 实现：抽象类的子类使用 `extends` 来继承；接口必须使用 `implements` 来实现接口。
- 构造函数：抽象类可以有**构造函数**；接口不能有。
- main方法：抽象类可以有`main`方法，并且我们能运行它；接口不能有 main方法。
- 实现数量：类可以实现**很多个接口**；但是只能继承**一个抽象类**。
- 访问修饰符：接口中的方法默认使用`public`修饰；抽象类中的方法可以是任意访问修饰符。
- 抽象是对类的抽象，是一种模板设计，接口是对行为的抽象，是一种行为规范



### new关键字

new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）。



#### 异常处理

ava.lang包中的 `Throwable类`是所有异常的父类， `Throwable类`的两个子类：Exception（异常）和Error（错误），其中包含大量的子类，一般情况下，不需要自己自定义异常类，需要实现自定义Throwable接口

**Error（错误）:是程序无法处理的错误**，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，

例如：StackOverFlowerError（栈内存移除），OutOfMemoryError（堆内存溢出）

异常捕捉：try…catch…finally

抛出异常：throws



#### Java的序列化

##### Java原生序列化	

使用Java原生流（Input/OutputStream流技术）

##### Jackson序列化

JSON作为服务器端大多是公司选择的数据返回格式，

##### FastJSON序列化

阿里巴巴开发的使用Java解析器和生成器



#### java中的IO流

按功能来分：**输入流（input）、输出流（output）**。

按类型来分：**字节流和字符流**。

字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

缓存流：低级流升级为高级流



#### BIO/NIO有什么区别 

**BIO **：同步阻塞模式，数据的读写都在一条线程中执行，阻塞在一条线程内等待期其完成，其开发难度较低，不必考虑系统的过载和限流问题，每一个连接只专注自己的IO，有线程池的缓冲，可以缓解系统的压力，但是面对数以万计的连接IO就效果不佳了

**NIO** ：同步非阻塞模式，添加了Channel、Selector、Buffer等抽象，支持阻塞和非阻塞模式，非阻塞模式适用于高负载高并发的场景

**AIO** ：Java7中引入的，相当于NIO的改进版，AIO是异步IO的缩写，



##### 常用的IO流

FileInputStream、FileOutputStream

FileReader、FileWriter

BufferedInputStream、BufferOutputStream、BufferedReader、BufferedWriter

 

#### files的常用方法

- Files.exists()：检测文件路径是否存在。
- Files.createFile()：创建文件。
- Files.createDirectory()：创建文件夹。
- Files.delete()：删除一个文件或目录。
- Files.copy()：复制文件。
- Files.move()：移动文件。
- Files.size()：查看文件个数。
- Files.read()：读取文件。
- Files.write()：写入文件。



#### Collection和Collections

collection是**集合接口**，封装了直接继承接口有List与Set的对集合对象进行基本操作的通用接口方法

collections是集合的一个**工具类帮助类**，中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。



#### List、Set、Map

![](/640.webp)



#### HashMap的实现原理

HashMap适用于**多插入、删除和定位元素**这类操作，TreeMap适合**多遍历查询**的场景

HashMap是基于哈希表的Map接口的非同步实现



#### ArrayList的循环

三种循环方式：普通for循环、增强for循环和迭代器循环



#### Java的对象引用

从JDK1.2开始，将对象的引用分为四种类型，使得程序能更加灵活的控制对象的生命周期

- **强引用**
  如果一个对象具有强引用，那么垃圾回收器**绝不会回收它**。**哪怕内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题**。
- **软引用**
  如果一个对象只具有软引用，**如果内存空间足够，垃圾回收器就不会回收它**，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
- **弱引用**
  如果一个对象只具有弱引用，垃圾回收器一旦发现了只具有弱引用的对象，**不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
- **虚引用**
  "虚引用"顾名思义，就是***形同虚设***，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。



#### 迭代器Iterator

迭代器也是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，被称为“轻量级”对象，因为创建它的代价小。

```java
while (iterator.hasNext()) {
   System.out.print(iterator.next());  
}
```



#### 并行和并发

- **并行**是指两个或者多个事件在**同一时刻**发生（多核处理器在多个处理器中执行多个事件）；而***并发***是指两个或多个事件在**同一时间间隔**发生（在单核处理器中执行多个事件）。
- 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
- 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。
- 并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。



#### 线程和进程

- 程序是含有指令和数据文件存储在磁盘或是内存中，进程是**程序运行**和**资源分配**的基本单位，线程是程序的最小执行单元
- 一个程序至少有一个进程，一个进程至少有一个线程。**进程在执行过程中拥有独立的内存单元**，**而多个线程共享内存资源**，减少切换次数，从而效率更高
- **线程是进程的一个实体**，是cpu调度和分配的基本单位，是比程序更小的能独立运行的**基本单位**
- 同一进程中的多个线程之间可以并发执行，最大限度的发挥处理器的性能。



#### 创建线程的方式

1. 继承`Thread`类创建线程类

   - 定义`Thread`类的子类，并重写该类的`run()`方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称执行体。
   - 创建`Thread`子类的实例，即创建了线程对象。
   - 调用线程对象的`start()`方法来启动该线程。

2. 通过`Runnable`接口创建线程类

   - 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
   - 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程象。
   - 调用线程对象的start()方法来启动该线程。

3. 通过Callable和Future创建线程

   

#### sleep()和wait()有什么区别

**sleep()**：方法是线程类（Thread）的**静态方法**，让调用线程进入**睡眠状态**，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间，线程虽然进入休眠，但是对象的**机锁没有被释放**，**其他线程依然无法访问这个对象。**

**wait()**：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程



#### 线程的五种状态

新建、就绪、执行、阻塞/挂起，消亡

线程的生命周期是不是保持在某个状态，而是在不同的状态中切换



#### notify()和notifyAll()的区别

- 如果线程调用了wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁
- 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。区别是：notify()是唤醒一个，notifuAll()是唤醒等待池中的所有线程到锁池中，等待锁竞争



#### 线程的run()和start()区别

start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码

run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的,run让本线程执行单不等于开辟了一个线程，所以会根据代码的先后顺序决定线程的执行顺序



#### 创建线程池的方式

- newFixedThreadPool(int nThreads)

  创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量

- newCachedThreadPool()

  创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制

- newSingleThreadExecutor()

  这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行

- newScheduledThreadPool(int corePoolSize)

  创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer



#### ThreadLocal

ThreadLocal提供了线程的局部变量，每个线程都可以通过`set()`和`get()`来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，**实现了线程的数据隔离**～。

ThreadLocal可以拥有当前线程的变量



#### 线程死锁

死锁是指两个线程在执行过程中，由于**竞争资源**或者**彼此通信**而造成了一种**阻塞的现象**，若无外力作用，这种状态会一直持续下去，这些永远在互相等待的线程是死锁



#### 死锁的四个条件

**互斥性**：当前进程所分配的资源，其他资源不能访问，其他线程需要访问该资源，<u>必须等待当前线程执行完毕释放该资源</u>

**环路等待条件**：若干进程之间处于头尾相连的循环等待资源关系

**请求和保持条件**：进程获得一部分资源，对其他资源继续访问，但可能当前对象被其他占用造成阻塞，但是又对自己的资源占用状态保持不放

**不可剥脱条件**：进程已获得的资源，在<u>未使用完之前，不可被剥脱</u>

（1） 因为系统资源不足。
（2） 进程运行推进的顺序不合适。
（3） 资源分配不当等。



#### Synchronized底层实现原理

保证在方法和代码块在运行的时候，同一时刻只有<u>一个线程能够访问到共享资源</u>，同时保证变量的**可见性**和**共享性**



#### Synchronized和volatile

- volatile本质是在告诉JVM当前变量在**寄存器**（工作内存）中的值是**不确定**的，需要从主存中读取， `synchronized`则是锁定当前变量，<u>只有当前线程可以访问该变量，其他线程被阻塞住</u>
- volatile仅能使用在**变量级别**；synchronized则可以使用在**变量、方法、和类级别**的。
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。



#### Synchronized和lock有什么区别

- synchronized是java内置关键字，在jvm层面，Lock是个java类
- synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁
- synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，
- Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题
- synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）



#### JavaWeb和JSP

#### JSP内置对象

- request：封装客户端的请求，其中包含来自GET或POST请求的参数；
- response：封装服务器对客户端的响应；
- pageContext：通过该对象可以获取其他对象；
- session：封装用户会话的对象；
- application：封装服务器运行环境的对象；
- out：输出服务器响应的输出流对象；
- config：Web应用的配置对象；
- page：JSP页面本身（相当于Java程序中的this）；
- exception：封装页面抛出异常的对象



#### JSP的4种作用域

page：代表一个页面相关的对象和属性

request：代表与Web客户机发出的一个请求的对象和属性，一个请求可能会跨越多个页面

session：用户与服务器建立一次会话，关于用户相关的东西要放在session中

Application：代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域



#### session和cookie

- HTTP是无状态协议，不会记录用户的行为和状态，有时候需要记录用户的状态，需要用某种机制来识别具体的用户

  例如：添加购物车的时候需要知道是那和用户的操作，服务端要为指定用户创建特定的session，用于表示当前用户，服务端保存session的方法很多种，内存、数据库、文件等，大型网站中，session是被放在session服务器集群的内存中

- 服务器端在创建session的时候，会在HTTP协议中告诉客户端，Cookie中会携带一个sessionID ，保存在客户端，客户端每次请求的时候将cookie的Id发送给服务器端，服务器就可以识别用户
- session是服务器端保存的一个数据结构，用来跟踪用户的状态，cookie是客户端保存用户信息的机制，用户在某些需要登录的场景就可以保存登录状态信息，也是session的一种实现方式



#### session的工作原理

其实session是一种存在服务器上类似散列表格的键值对文件，相当于一个大的map，用户向服务器发送指定的Id就能获取到相应的session状态



#### throw和throws的区别

throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。



#### Lock(锁)

● 从JDK 5.0开始，Java提供了更强大的线程同步机制一通过 显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

● java.util.concurrent.locks.Lock接 口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

● ReentrantLock 类实现了Lock，它拥有与synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。

lock是一个接口，其实使用的是lock接口的子类ReentrantLock

lock需要手动实现同步，同时结束同步也需要手动的实现



#### forward 和 redirect 的区别

**forward（转发）**：

是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址.

例子：a去找b借钱，b没有向c借钱，不管有没有成功都会返回一个结果给a

**redirect（重定向）**：

是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

例子：a找b借钱，b没有，就告诉b自己找c

**转发是服务器行为，重定向是客户端行为**



### 计算机网络

#### TCP和UDP协议

- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
- Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。



#### TCP和UDP的使用场景

TCP：文件传输或者版本更新，必须所有的完完整整的发送接收，不能有丢包的现象

UDP：视频电话或是实时通信，有时候视频卡顿，尽肯能快的放在网络上，有时候会存在丢包的现象



#### UDP（User Data Protocol，用户数据报协议）

UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制



#### TCP三次握手

第一次握手：主机A通过向主机B 发送一个含有**同步序列号**的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：**我想要和你通信；你可以用哪个序列号作为起始数据段来回应我**。

第二次握手：主机B 收到主机A的请求后，用一个带有**确认应答（ACK）**和**同步序列号（SYN）**标志位的数据段响应主机A，也告诉主机A两件事：**我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我**

第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："**我已收到回复，我现在要开始传输实际数据了**，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

建立连接需要三次握手，断开连接需要告诉连接的主机，告诉它我要断开连接，四次握手



#### OSI参考模型

应用层

表示层

会话层

传输层

网络层

数据链路层

物理层



#### GET和POST请求

**根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。** 

所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

与之对应的，POST会改变资源的状态，修改或者更新等操作

Get请求的参数数据会附在URL之后，以？区分URL和传输数据，POST提交的数据是在HTTP的包头中

GET请求的数据最多是1024字节，POST是没有限制的



### Java框架

#### Spring的优点

简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架

- 完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布
- Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。



#### IOC的背景

在面向对象语言系统中，是有N个对象组成的，对象与对象之间的合作组成了系统的业务逻辑，在传统的未使用IOC容器的系统中，对象与对象好似一个一个的小齿轮一起转动，耦合度较高，会出现一个问题，其中一个对象齿轮出现问题，可能会所有的轮子都无法转动，牵一发动全身

IOC容器相当于是一个大齿轮，其他的小齿轮围绕IOC齿轮工作，借助第三方容器对象降低耦合，其中一个齿轮停止工作不会影响大齿轮的工作  



#### AOP

核心思想是基于代理模式，SpringAOP支持静态代理模式、JDK动态代理、CGLIB动态代理、ASPECTJ动态代理

计算机语言中的编程范式：面向过程编程（c语言）、面向对象编程（Java，C++）、函数式编程、事件驱动编程、面向切面编程

AOP是一种编程范式，并不是编程语言，解决特定的问题，将某一多次重复多用的模块抽离出来称为`公共模块`，面向切面编程是对OOP面向对象语言的补充，并不是替代

补充：JDK动态代理只能代理接口，不能代理类，Sprig默认是使用JDK动态代理，需要代理类的时候用AspectJ代理

##### AOP的引用场景

权限控制、事务管理、性能监控、分布式追踪、异常处理

##### AOP的基本概念

- 五种通知类型

  `Before` 在方法被调用之前调用

  `After` 在方法完成后调用通知，无论方法是否执行成功

  `After-returning` 在方法成功执行之后调用通知

  `After-throwing` 在方法抛出异常后调用通知

  `Around` 通知了好、包含了被通知的方法，在被通知的方法调用之前后调用之后执行自定义的行为

  通知更多的作用是告诉系统运行的某个时间点，执行某个操作（方法执行、抛出异常）

- 切点

  在系统中对应的是类中的方法，一般和通知一起使用，一起组成了切面

- 连接点

  连接点就是在系统中任意一个准备切入通知或执行切点的地方，比如：方法调用、方法执行、字段设置/获取、异常处理执行、类初始化、甚至是 for 循环中的某个点

- 切面

  切点和通知的组合，一般单独作为一个类，切点和通知定义了系统在什么时候在什么地方要执行什么功能

- 引入

  允许向现有的类添加新的方法或者属性

- 织入

  

##### 基于AspectJ实现的AOP

SpringAOP使用的是AspectJ注解，但不是Spring团队开发的AspectJ，AspectJ是一个与Java可以无缝集成的AOP框架，AspectJ本身是静态织入，而SpringAOP的是动态织入，Spring只是使用了AspectJ的注解，并没有使用它的编译器，底层依旧是使用的动态代理的技术 

`@Aspect`表示这是一个切面类



#### Spring的事务

事务是一组操作，要么全部都执行，要么不执行



##### 事务的ACID  

**原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

**一致性：** 执行事务前后，数据保持一致；

**隔离性：** 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；

**持久性:**  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。



##### Spring的事务接口

Spring不对事务直接控制，而是提供了多种事务管理器，

- **PlatformTransactionManager：** （平台）事务管理器
- **TransactionDefinition：** 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)
- **TransactionStatus：** 事务运行状态

在Spring中主要使用的就是`PlatformTransactionManager`接口为主要实现类（与Mybatis整合的时候加载配置文件就会遇到事务管理器），与数据库的操作也是事务，要么全部执行，要不全部都不执行，如果中间因为某些原因持久化失败，也要执行回滚RallBack操作



##### PlatformTransactionManager详解

**org.springframework.jdbc.datasource.DataSourceTransactionManager**	使用Spring JDBC或者iBatis进行持久化数据时使用
**org.springframework.orm.hibernate3.HibernateTransactionManager**	使用Hibernate3.0版本进行持久化数据时使用
**org.springframework.orm.jpa.JpaTransactionManager**	使用JPA进行数据持久化时使用
**org.springframework.transaction.jta.JtaTransactionManager**	使用一一个JTA实现来管理事务，在一一个事务跨越多个资源时使用



##### 事务的六大属性

- 事务隔离级别

  事务必定会遇到并发的问题

  **脏读：**当一个事务读取一个数据并对其进行了修改，但是还没有提交到数据库中，另一个事务读取了该数据，这时候该数据并不是原来的数据，称之为“脏数据”，脏数据和原数据不一样，所有另一个事务对脏数据的操作是不正确的

  **丢失修改：**事务A修改了数据后，事务B也修改了数据，这回导致事务A修改的结果丢失

  例子：A修改了数据20为21，B修改该数据为19，数据20>21>19，这时候A修改的数据21的结果丢失

  **不可重复读**：事务A多次读取同一个数据，在读完一次后事务B对数据进行了修改，事务A第二次读取数据的时候，因为该数据已经被修改了，这时候读出的两次结果不一致   （重点是修改）

  **幻读：**事务A读取了几行数据，事务B新增了几条数据，事务A再次读取数据的时候，会凭空多出几条数据 ，就像凭空出现的缓解一样（重点是新增和删除）

  **数据库隔离级别**

  **TransactionDefinition.ISOLATION_DEFAULT:**	使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.

  **TransactionDefinition.ISOLATION_READ_UNCOMMITTED:** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**

  **TransactionDefinition.ISOLATION_READ_COMMITTED:** 	允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**

  **TransactionDefinition.ISOLATION_REPEATABLE_READ:** 	对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**

  **TransactionDefinition.ISOLATION_SERIALIZABLE:** 	最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

- 事务传播行为

  

- 事务只读属性

  

- 事务超时属性

- 回滚规则



#### MySQL相关

`mysql`常用引擎包括：`MYISAM`、`Innodb`、`Memory`、`MERGE`

- `MYISAM`：**全表锁**，拥有**较高的执行速度**，**不支持事务，不支持外键**，并发性能差，占用空间相对较小，对事务完整性没有要求，以`select、insert`为主的应用基本上可以使用这引擎
- `Innodb`:行级锁，提供了具有**提交、回滚和崩溃回复**能力的事务安全，支持自动增长列，支持**外键约束**，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些（大多都是这个引擎）
- `Memory`:全表锁，存储在内容中，**速度快，但会占用和数据量成正比**的内存空间且数据在`mysql`重启时会丢失，默认使用**HASH索引**，检索效率非常高，但不适用于精确查找，主要用于那些内容变化不频繁的代码表
- `MERGE`：是一组MYISAM表的组合



#### TCP的三次握手和四次握手

[关于计算机网络的相关知识总结](<https://hit-alibaba.github.io/interview/basic/network/TCP.html>)

TCP 提供一种**面向连接的、可靠的**字节流服务，是基于IP的传输层协议，面向连接的比喻**就是打电话的时候必须双方都建立起连接才能通话**

建立连接需要三次握手，断开连接则需要四次握手

所谓**三次握手**(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包，三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的**序列号**和**确认号**，交换 TCP 窗口大小信息

- 第一次握手：确认服务器可以发送和接受数据
- 第二次握手：客户端确认自己和服务器可以接受发送数据，服务端确认客户端可以接受数据
- 第三次握手：客户端确认自己和服务器可以接受发送数据，服务端确认客户端可以发送和接受数据
- 



#### 48.谈谈SpringMVC的工作原理

- 客户端请求提交到DispatcherServlet
- 由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller
- DispatcherServlet将请求提交到Controller
- Controller调用业务逻辑处理后，返回ModelAndView
- DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图
- 视图负责将结果显示到客户端