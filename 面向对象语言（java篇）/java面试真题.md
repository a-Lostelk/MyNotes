---
typora-root-url: images
---

#### == 和 equals 的区别是什么？

##### == 解读

- **基本类型**：比较的是值是否相同；
- **引用类型**：比较的是引用是否相同；

new一个对象会开辟新的内存空间，除非和对象本身的比较，==结果是false

##### equals解读

equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较

**总结** ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用（内存地址）；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。



#### final的作用

- final 修饰的类叫**最终类**，该类不能被继承。
- final 修饰的方法不能被重写。
- final 修饰的变量叫**常量**，常量必须**初始化**，初始化之后值就不能被修改。



#### 字符串类区别

String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象

而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的

线程安全高执行效率低，线程安全低执行效率低



#### String str="i"与 String str=new String("i")

内存分配的方式不一样，String str = "i"会将其分配到常量池中，String str = new String("i")开辟新的内存空间，放入到堆内存中



#### String类的常用方法


indexOf()：返回指定字符的索引。

charAt()：返回指定索引处的字符。

replace()：字符串替换。

trim()：去除字符串两端空白。

split()：分割字符串，返回一个分割后的字符串数组。

getBytes()：返回字符串的 byte 类型数组。

length()：返回字符串长度。

toLowerCase()：将字符串转成小写字母。

toUpperCase()：将字符串转成大写字符。

substring()：截取字符串。

equals()：字符串比较。



#### 抽象类和普通类的区别

- 普通类不能包含抽象方法，抽象类可以包含抽象方法。
- 抽象类不能直接实例化，普通类可以直接实例化。
- 抽象类不能被Final修饰



#### 接口类和抽象类的区别

- 实现：抽象类的子类使用 **extends** 来继承；接口必须使用 **implements** 来实现接口。
- 构造函数：抽象类可以有**构造函数**；接口不能有。
- main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。
- 实现数量：类可以实现**很多个接口**；但是只能继承**一个抽象类**。
- 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。



#### java中的IO流

按功能来分：**输入流（input）、输出流（output）**。

按类型来分：字节流和字符流。

字节流和字符流的区别是：字节流按8位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

 

#### files的常用方法

- Files.exists()：检测文件路径是否存在。
- Files.createFile()：创建文件。
- Files.createDirectory()：创建文件夹。
- Files.delete()：删除一个文件或目录。
- Files.copy()：复制文件。
- Files.move()：移动文件。
- Files.size()：查看文件个数。
- Files.read()：读取文件。
- Files.write()：写入文件。



#### Collection和Collections

collection是集合接口，封装了直接继承接口有List与Set的对集合对象进行基本操作的通用接口方法

collections是集合的一个工具类帮助类其，中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。



#### List、Set、Map

![](/640.webp)



#### HashMap的实现原理

HashMap适用于多插入、删除和定位元素这类操作，TreeMap适合多遍历的场景

HashMap是基于哈希表的Map接口的非同步实现



#### 迭代器Iterator

迭代器也是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，被称为“轻量级”对象，因为创建它的代价小。

```java
while (iterator.hasNext()) {
   System.out.print(iterator.next());  
}
```



#### 并行和并发

- 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
- 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
- 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。
- 并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。

#### 线程和进程

- 进程是程序运行和资源分配的基本单位
- 一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高
- 线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位
- 同一进程中的多个线程之间可以并发执行。



#### 创建线程的方式

1. 继承**Thread**类创建线程类

   - 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称执行体。
   - 创建Thread子类的实例，即创建了线程对象。
   - 调用线程对象的start()方法来启动该线程。

2. 通过**Runnable**接口创建线程类

   - 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
   - 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程象。
   - 调用线程对象的start()方法来启动该线程。

3. 通过Callable和Future创建线程

   

#### sleep()和wait()有什么区别

**sleep()**：方法是线程类（Thread）的**静态方法**，让调用线程进入**睡眠状态**，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间，线程虽然进入休眠，但是对象的**机锁没有被释放**，***其他线程依然无法访问这个对象。***

**wait()**：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程



#### notify()和notifyAll()的区别

- 如果线程调用了wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁
- 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。区别是：notify()是唤醒一个，notifuAll()是唤醒等待池中的所有线程到锁池中，等待锁竞争



#### 线程的run()和start()区别

start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码

run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的,run让本线程执行单不等于开辟了一个线程



#### 创建线程池的方式

- newFixedThreadPool(int nThreads)

  创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量

- newCachedThreadPool()

  创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制

- newSingleThreadExecutor()

  这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行

- newScheduledThreadPool(int corePoolSize)

  创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer



#### 线程死锁

死锁是指两个线程在执行过程中，由于竞争资源或者彼此通信而造成了一种阻塞的现象，若无外力作用，这种状态会一直持续下去，这些永远在互相等待的线程是死锁



#### 死锁的四个条件

互斥性：当前进程所分配的资源，其他资源不能访问，其他线程需要访问该资源，必须等待当前线程执行完毕释放该资源

环路等待条件：若干进程之间处于头尾相连的循环等待资源关系

请求和保持条件：进程获得一部分资源，对其他资源继续访问，但可能当前对象被其他占用造成阻塞，但是又对自己的资源占用状态保持不放

不可剥脱条件：进程已获得的资源，在未使用完之前，不可被剥脱

（1） 因为系统资源不足。
（2） 进程运行推进的顺序不合适。
（3） 资源分配不当等。



#### Synchronized底层实现原理

保证在方法和代码块在运行的时候，同一时刻只有一个线程能够访问到共享资源，同时保证变量的可见性和共享性



#### Synchronized和volatile

- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取， synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住
- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。



#### Synchronized和lock有什么区别

- synchronized是java内置关键字，在jvm层面，Lock是个java类
- synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁
- synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，
- Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题
- synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）



#### JSP内置对象

- request：封装客户端的请求，其中包含来自GET或POST请求的参数；
- response：封装服务器对客户端的响应；
- pageContext：通过该对象可以获取其他对象；
- session：封装用户会话的对象；
- application：封装服务器运行环境的对象；
- out：输出服务器响应的输出流对象；
- config：Web应用的配置对象；
- page：JSP页面本身（相当于Java程序中的this）；
- exception：封装页面抛出异常的对象



#### JSP的4种作用域

page：代表一个页面相关的对象和属性

request：代表与Web客户机发出的一个请求的对象和属性，一个请求可能会跨越多个页面

session：用户与服务器建立一次会话，关于用户相关的东西要放在session中

Application：代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域



#### session和cookie

- HTTP是无状态协议，不会记录用户的行为和状态，有时候需要记录用户的状态，需要用某种机制来识别具体的用户

  例如：添加购物车的时候需要知道是那和用户的操作，服务端要为指定用户创建特定的session，用于表示当前用户，服务端保存session的方法很多种，内存、数据库、文件等，大型网站中，session是被放在session服务器集群的内存中

- 服务器端在创建session的时候，会在HTTP协议中告诉客户端，Cookie中会携带一个sessionID ，保存在客户端，客户端每次请求的时候将cookie的Id发送给服务器端，服务器就可以识别用户
- session是服务器端保存的一个数据结构，用来跟踪用户的状态，cookie是客户端保存用户信息的机制，用户在某些需要登录的场景就可以保存登录状态信息，也是session的一种实现方式



#### session的工作原理

其实session是一种存在服务器上类似散列表格的键值对文件，相当于一个大的map，用户向服务器发送指定的Id就能获取到相应的session状态



#### throw和throws的区别

throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。



#### Lock(锁)

● 从JDK 5.0开始，Java提供了更强大的线程同步机制一通过 显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

● java.util.concurrent.locks.Lock接 口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

● ReentrantLock 类实现了Lock，它拥有与synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。

lock是一个接口，其实使用的是lock接口的子类ReentrantLock

lock需要手动实现同步，同时结束同步也需要手动的实现



#### forward 和 redirect 的区别

**forward（转发）**：

是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址.

例子：a去找b借钱，b没有向c借钱，不管有没有成功都会返回一个结果给a

**redirect（重定向）**：

是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

例子：a找b借钱，b没有，就告诉b自己找c

**转发是服务器行为，重定向是客户端行为**



#### TCP和UDP协议

- TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
- TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
- Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 

